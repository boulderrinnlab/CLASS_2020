---
title: "Clustering by Features"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
options(stringsAsFactors = FALSE)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(GenomicRanges)
library(GenomicFeatures)
library(rtracklayer)
library(ggrepel)
library(Rsubread)
library(effectsize)
source("/Shares/rinn_class/data/k562_chip/analysis/util/intersect_functions.R")
source("/Shares/rinn_class/data/k562_chip/analysis/util/_setup.R")

```

Get RNAseq data from here: 
total RNA-seq for K562 dataset: https://www.encodeproject.org/experiments/ENCSR885DVH/

# system("wget https://www.encodeproject.org/files/ENCFF625ZBS/@@download/ENCFF625ZBS.bam",
#        intern = FALSE, ignore.stdout = TRUE, ignore.stderr = TRUE)
# system("wget https://www.encodeproject.org/files/ENCFF630HEX/@@download/ENCFF630HEX.bam",
#        intern = FALSE, ignore.stdout = TRUE, ignore.stderr = TRUE)

```{r converting read counts to TPM}

# First we will take the bam file and find the number of reads that align over mRNA and lncRNA gene-bodies 

counts <- featureCounts(c("/Shares/rinn_class/data/k562_chip/analysis/09_expression/ENCFF625ZBS.bam",
                          "/Shares/rinn_class/data/k562_chip/analysis/09_expression/ENCFF630HEX.bam"),
                        annot.ext = "/Shares/rinn_class/data/genomes/human/gencode/v32/gencode.v32.annotation.gtf",
                        isGTFAnnotationFile = T,
                        isPairedEnd = TRUE,
                        nthreads = 16)

# First we will find the number of reads per kilobases of a given gene body (rpkm).

rpk <- counts$counts / (counts$annotation$Length/1000)
expression <- data.frame("rpk" = rpk) %>%
  rownames_to_column("gene_id") %>%
  pivot_longer(2:3, names_to = "sample", values_to = "rpk")

# Here we will convert rpkm to transcripts per million of reads (tpm)

expression_summary <- expression %>%
  group_by(sample) %>%
  summarize(total_rpk = sum(rpk, na.rm = T))
expression_summary$rpk_m <- expression_summary$total_rpk / 1e6
expression <- merge(expression, expression_summary)
expression$tpm <-expression$rpk / expression$rpk_m
tpm <- expression %>% group_by(gene_id) %>%
  summarize(tpm = mean(tpm, na.rm = T))
```


# The first step is to get a matrix of features by TFs.

```{r}
# We are going to start out with a function to import files called "import_peaks"
# This the filtered peak_list; final list of 161 TFs after filtering
peak_list <- import_peaks("/Shares/rinn_class/data/CLASS_2020/analysis/01_consensus_peaks/results/")

# Making the features (gencode) GRanges that has lots of features annotated
gencode_gr <- rtracklayer::import("/Shares/rinn_class/data/genomes/human/gencode/v32/gencode.v32.annotation.gtf")

# Here we are using the function "get_promoter_regions" to grab both the lncRNA and mRNA promoters
proms <- get_promoter_regions(gencode_gr, biotype = c("lncRNA", "protein_coding"))

# Counts the number of promoters that each TF binds to
promoter_peak_count <- count_peaks_per_feature(proms, peak_list)
```


Finding ghosts
Reservoirs/Ghost promoters: Promoters with TFs binding but without expression (Note: Here in the script we are using the term "ghosts" and they are same as the reservoirs)
```{r}
# Make this binary -- a co-occurence matrix (the promoters bound by TFs).
promoter_peak_occurence <- matrix(as.numeric(promoter_peak_count > 0),
                           nrow = dim(promoter_peak_count)[1],
                           ncol = dim(promoter_peak_count)[2])
rownames(promoter_peak_occurence) <- rownames(promoter_peak_count)
colnames(promoter_peak_occurence) <- colnames(promoter_peak_count)

# Make a data frame of binding events per promoter.
peak_occurence_df <- data.frame("gene_id" = colnames(promoter_peak_occurence),
                                "number_of_tfs" = colSums(promoter_peak_occurence))

# Merge in the expression data into the data frame we just created.
peak_occurence_df <- merge(peak_occurence_df, tpm)
total_proms <- peak_occurence_df %>% filter(number_of_tfs > 7)

# Defining ghosts here
ghosts <- peak_occurence_df %>% filter(number_of_tfs > 7, tpm < 0.001)
## subset columns that correspond to ghosts
ghost_peak_occurence <- promoter_peak_occurence[, colnames(promoter_peak_occurence) %in% ghosts$gene_id]

```

Hypergeometric test
```{r}
# t is overlaps of ghosts on superenhancers = 35
# n is total promoters with > 7 binding events = 16826
# a is number of ghosts = 1362
# b is number of superenhancers = 714

# dhyper(t, a, n - a, b)
# sum(dhyper(t:b, a, n - a, b))

dhyper(35, 714, 16826 - 714, 1362)
sum(dhyper(35:1362, 714, 16826 - 714, 1362))

```


# Now that we have a binary matrix and counts of number of features that intersect with DNA binding events -- let's cluster to see if the grouping makes sense
# We are using a binary matrix that calculates the distance betweeen each sample using the binary distance metric. 

```{r}

# Calculate a distance measure between the rows.
bin_hier <- hclust(dist(ghost_peak_occurence, method = "binary"))
plot(bin_hier)

# load library for ggdendro for the best trees we could find 
library(ggdendro)

ggdendro::ggdendrogram(bin_hier, rotate = TRUE,  size = 3)
ggsave("figures/ghost_binary_dist.pdf", height = 26, width = 6)

```
