---
title: "DNA-binding versus expression at promoters"
output: html_document
editor_options:
  chunk_output_type: console
---


```{r setup, include=FALSE}
options(stringsAsFactors = F)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(GenomicRanges)
library(GenomicFeatures)
library(rtracklayer)
#library(ggbio)
library(ggrepel)
library(Rsubread)
library(effectsize)
source("/Shares/rinn_class/data/k562_chip/analysis/util/intersect_functions.R")

```


#### This is where the data came from

total RNA-seq for K562 dataset: https://www.encodeproject.org/experiments/ENCSR885DVH/

# system("wget https://www.encodeproject.org/files/ENCFF625ZBS/@@download/ENCFF625ZBS.bam",
#        intern = FALSE, ignore.stdout = TRUE, ignore.stderr = TRUE)
# system("wget https://www.encodeproject.org/files/ENCFF630HEX/@@download/ENCFF630HEX.bam",
#        intern = FALSE, ignore.stdout = TRUE, ignore.stderr = TRUE)


```{r converting read counts to TPM}

# First we will take the bam file and find the number of reads that align over mRAN and lncRNA gene-bodies (similar to what we used in MACs)
# Don't worry about the syntax of the following code as it pertains to RNAseq, but maybe worth a google :)

counts <- featureCounts(c("/Shares/rinn_class/data/k562_chip/analysis/09_expression/ENCFF625ZBS.bam",
                          "/Shares/rinn_class/data/k562_chip/analysis/09_expression/ENCFF630HEX.bam"),
                        annot.ext = "/Shares/rinn_class/data/genomes/human/gencode/v32/gencode.v32.annotation.gtf",
                        isGTFAnnotationFile = T,
                        isPairedEnd = TRUE,
                        nthreads = 16)

# First we will find the number of reads per kilobases of a given gene body (rpkm).
# Q: Why would we want to normalize to the size of the genebody?
rpk <- counts$counts / (counts$annotation$Length/1000)
expression <- data.frame("rpk" = rpk) %>%
  rownames_to_column("gene_id") %>%
  pivot_longer(2:3, names_to = "sample", values_to = "rpk")

# Here we will convert rpkm to transcripts per million of reads (tpm)
# Q: why would we need to furhter normalize this way?
expression_summary <- expression %>%
  group_by(sample) %>%
  summarize(total_rpk = sum(rpk, na.rm = T))
expression_summary$rpk_m <- expression_summary$total_rpk / 1e6
expression <- merge(expression, expression_summary)
expression$tpm <-expression$rpk / expression$rpk_m
tpm <- expression %>% group_by(gene_id) %>%
  summarize(tpm = mean(tpm, na.rm = T))
```


```{r}

# 1. Read in consensus peaks as a list.
consensus_peaks <- import_peaks("/Shares/rinn_class/data/CLASS_2020/analysis/01_consensus_peaks/results/")

# 2. Read in gencode.
gtf <- rtracklayer::import("/Shares/rinn_class/data/genomes/human/gencode/v32/gencode.v32.annotation.gtf"
)

# 3. Get the promoter regions of each gene.

proms <- get_promoter_regions(gencode_gr = gtf, biotype = c("lncRNA", "protein_coding"),
                              upstream =3000, downstream = 3000)


# 4. Count peaks over promoters

promoter_peak_count <- count_peaks_per_feature(features = proms, peak_list = consensus_peaks )

```

```{r}
# Make this binary -- a co-occurence matrix.
promoter_peak_occurence <- matrix(as.numeric(promoter_peak_count > 0),
                           nrow = dim(promoter_peak_count)[1],
                           ncol = dim(promoter_peak_count)[2])
rownames(promoter_peak_occurence) <- rownames(promoter_peak_count)
colnames(promoter_peak_occurence) <- colnames(promoter_peak_count)



# Make a data frame of binding events per promoter.
peak_occurence_df <- data.frame("gene_id" = colnames(promoter_peak_occurence),
                                "number_of_tfs" = colSums(promoter_peak_occurence))

# Merge in the expression data into the data frame you just created.

peak_occurence_df <- merge(peak_occurence_df, tpm)

ghosts <- peak_occurence_df %>% filter(number_of_tfs > 7, tpm < 0.001)
## subset columns that correspond to ghosts
ghost_peak_occurence <- promoter_peak_occurence[, colnames(promoter_peak_occurence) %in% ghosts$gene_id]

not_ghosts <- peak_occurence_df %>% filter(number_of_tfs > 7, tpm > 0.001)
not_ghost_peak_occurence <- promoter_peak_occurence[,colnames(promoter_peak_occurence) %in% not_ghosts$gene_id]

```

```{r}
ghost_num_overlaps <- rowSums(ghost_peak_occurence)
not_ghost_num_overlaps <- rowSums(not_ghost_peak_occurence)
num_peaks <- sapply(consensus_peaks, length)
total_ghosts <- length(ghosts)
total_not_ghosts <- length(not_ghosts)
total <- total_ghosts + total_not_ghosts

chisq_res <- data.frame("tf" =character(),
                        "ghosts" = numeric(),
                        "chisq_stat" = numeric(),
                        "chisq_pval" = numeric(),
                        "not_ghosts" = numeric())

i <- 1
## How do we find expected number of ghosts??
for(i in 1:length(num_peaks)) {
  total_peaks <- num_peaks[[i]]
  df1 <- data.frame("ghosted" = c("ghost", "not_ghost"),
                    "promoter_bound" = c("bound", "not_bound"),
                    "counted" = c(ghost_num_overlaps[[i]], not_ghost_num_overlaps[[i]])) %>%
    pivot_wider(names_from = ghosted, values_from = counted) %>%
    as.matrix()
  
  csres <- chisq.test(df1)
  phi_coef <- phi(df1)
  tdf <- data.frame("tf" = names(num_peaks[i]),
                    "ghosted" = ghosts[[i]],
                    "chisq_stat" = csres$statistic,
                    "chisq_pval" = csres$p.value,
                    "phi_coefficient" = phi_coef$phi)
  chisq_res <- bind_rows(chisq_res, tdf)
}
```


```{r}
# Use what you just made to plot the results.
g <- ggplot(peak_occurence_df, aes(y = log10(tpm), x = number_of_tfs, color = gene_type))
g + geom_point(alpha = 0.2) +
  geom_smooth() +
  scale_y_continuous(expand = c(0,0)) +
  scale_x_continuous(expand = c(0,0)) +
  scale_color_manual(values = c("#424242","#a8404c"), name = "Gene type") +
  ggtitle("Promoter binding events vs. expression") +
  xlab(expression('Number of TFs')) +
  ylab(expression(log[10](tpm)))
ggsave("figures/k562_promoter_binding_vs_expression.png")
ggsave("figures/k562_promoter_binding_vs_expression.pdf")
```



```{r}
# With this data.frame, plot the distribution of expression across those two groups.

# For example...
# X should be your cutoff from above.
peak_occurence_df$tf_binding <- "low"
peak_occurence_df[which(peak_occurence_df$number_of_tfs > x), "tf_binding"] <- "high"

g <- ggplot(peak_occurence_df, aes(x = log10(tpm), color = tf_binding))
g + geom_density(alpha = 0.2)
```


```{r}
# Here's an example of a binned approach.
## Are these reasonable break points? How would consider changing them?
quantile(peak_occurence_df$tpm)
peak_occurence_df$expression <- cut(peak_occurence_df$tpm, breaks = c(-1, 0.001, 0.137, 3, 5000),
                                    labels = c("off", "low", "med", "high"))
table(peak_occurence_df$expression)

g <- ggplot(peak_occurence_df, aes(x = expression, y = number_of_tfs, color = gene_type))
g + geom_boxplot() + stat_compare_means() +
  scale_color_manual(values = c("#a8404c", "#424242"))
```

